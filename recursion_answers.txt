1. Define and compare recursion and iteration.

Recursion is when a function calls itself which results in repeating the same steps until the function is complete. 
Iteration is best defined with loops. A set of instructions is repeated, but in a specific amount of times until a condition is met.

2. Name five algorithms that are commonly implemented by recursion.

The fibonacci sequence
The factorial operation
How to see if a string is a palindrome
Finding the nth node in a linked list
Binary search involving breadth-first and depth-first traversal

3. When should you use recursion, and when should you avoid recursion? Give examples for each.

You should use recursion when you have to implement the same problem solving technique in every level of solving the issue. Such as the fibonacci sequence. It's a pattern that continuously uses adding the sum of the last and current number you received. This will happen every time you input a number. Recursion shouldn't be used when you have several steps of a problem that include different steps to solve the problem on each level. For example, if you have a restaurant menu that has 7 layers of data that needs to be iterated through, but on the 5th layer, there needs to be a 9% tax added, recursion would fail, because you cannot call the same function on that particular step.

4. Compare the recursive and iterative solutions to the three algorithms from the checkpoint (factorial, maximum, and fibonacci). What is similar, and what is different?

Factorial:
Recursive: The recursive solution doesn't keep track of the result, but simply calls the function until it reaches a conclusion or its base case.
Iterative: The iterative solution keeps track of the result in a variable to track the calculations.

They both use if/else statements to account for negative numbers and 0's being passed into the function.

Maximum:
Recursive: The recursive solution works almost backwards by calling the function until it reaches its base case. Once it reaches the base case, it works backwords by caling itself through the collection of numbers until it finds the largest number.
Iterative: The iterative solution is a little simpler in that we set the current maximum to the first number, then loop through the rest of the collection. You compare using an if/else if the current maximum is larger than your number you passed in, and you return your solution. 

They both seem to loop through in their own unique ways, but the iterative version seems faster.

Fibonacci:
Recursive: In the recursive solution, it calls fibonacci(2)twice because the lower values have to be recalculated because of the base cases. It looks for the higher values.
Iterative: The iterative solution skips over the first two problems, by saying that i has to be greater than or equal to 3 so you don't run the program to equal 1 at all since that's already known.

In both solutions, each number is saved in a variable and will change as the program attempts to find the solution for the number passed in.

5. Given a multi-dimensional collection (such as an array) where the number of dimensions is unknown, write a recursive algorithm to count the number of items in the entire collection.

let collectionNumber = array => {
  if(array.length){
    return 1 + collectionNumber(array.slice(1));
  } else {
    return 0;
  }
};

6. A palindrome is a word or phrase whose spelling is the same either direction (e.g., racecar). Write a recursive algorithm to determine if a given word or phrase is a palindrome.

let isPalindrome = str => {
    str = str.toLowerCase();
    if(str.length === 1){
        return true;
    } else if(str[0] !== str[str.length - 1]) {
        return false;
    }
    return isPalindrome(str.slice(1, -1));
};

console.log(isPalindrome('racecar'));

7. Google Easter Egg: Google the term "recursion". Google will prompt you with "Did you mean: recursion". Explain why this behavior exhibits properties of recursion.

This behavior shows an "infinite loop" that mimicks recursion because as long as you click on the link from "Did you mean recursion", you'll always end up at the same page with those same results. None of the base cases or termination cases applied, therefore Google's recursive function was executed thus putting the user in a recursive loop or infinite loop.