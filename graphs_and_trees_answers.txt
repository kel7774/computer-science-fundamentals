Exercises:

1. What is a binary tree and what makes it unique to other trees?

A binary tree is a data structure made up of nodes that contain pointers on the left and right that also contain a data element. A binary tree has a "root" pointer which is the topmost part of the tree. The left and right nodes point to smaller trees or "subtrees" making it unique from a linked list in that you can build more complex structures with left and right nodes.

2. What is a heuristic?

A heuristic is an algorithmic "best guess" at a complex problem that will take a reasonable amount of time to solve the problem, however, it may not be the most accurate or the best solution.

3. What is another problem besides the shortest-path problem that requires the use of heuristics?

One problem besides the shortest path is time accuracy. The company I work for provides our customers with an "estimated delivery time". This is for when a customer orders food from a restaurant, and the restaurant has a to select a prep time. Say the restaurant selects a 20 minute prep time to prepare the order. The customer will get a notification, but their notification will say, "Your food will be delivered in about 47 minutes." This is because the heuristic algorithm is taking into account how much time it will take a driver to A. Get to the restaurant, B. If the restaurant has a history of picking prep times that they exceed or are generally accurate, C. Google traffic updates at the current time of day, and many other factors. It's impossible to make an "exact" or accurate guess as to what time the customer will actually receive their food because of all of these factors that are not based on accuracy, but rather chance. A heuristic function typically suffices for such calculations.

4. What is the difference between a depth-first search and a breadth-first search?

Depth-First Search or DFS is a search that traverses the tree starting at the root and explores as far down each branch before having to backtrack.
Breadth-First Search or BDS is a search that traverses the tree starting at the root but explores the neighboring nodes (or rows) before moving to the next level of neighbors or nodes.

5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.

A graph that doesn't loop since it's a-cyclic, does not assign the cost of travel since it's unweighted and connection between two nodes is ambiguous because it neither starts nor ends at either node, just connects like a handshake since it's undirected.

6. What kind of graph is a binary search tree?

A binary search tree a undirected, a-cyclic, unweighted graph.


Programming Questions


1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.

function BST(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

BST.prototype.insert = function(value) {
    if(value <= this.value){
        if(!this.left){
            this.left = new BST(value);
        } else {
            this.left.insert(value);
        }
    } else if(value > this.value) {
        if(!this.right){
            this.right = new BST(value);
        } else {
            this.right.insert(value);
        }
    }
}

BST.prototype.contains = function(value) {
  if(value === this.value){
    return true;
  } else if (value < this.value){
    if(!this.left) return false;
    else return this.left.contains(value);
  } else if (value > this.value){
    if(!this.right) return false;
    else return this.right.contains(value);
  }
}

BST.prototype.lowestCommonAncestor = function(root, n1, n2){
  if(root > n1 && root > n2){
    console.log(`Left: ${this.left}`);
    console.log(`Left.value: ${this.left.value}`);
    return this.left.value;
  } else if (root < n1 && root < n2){
    console.log(`Right: ${this.right}`);
    console.log(`Right.value: ${this.right.value}`);
    return this.right.value;
  } else if(root === n1 && root === n2) {
    console.log(`Root: ${root}`);
    console.log(`Root.value: ${root.value}`);
    return root.value;
  }
}

BST.prototype.distance = function (n1, n2){
  let currentNode = this.lowestCommonAncestor(n1, n2);
  console.log(currentNode);
  let count1 = 0;
  let count2 = 0;
  let dist1 = currentNode => {
    if(n1 === currentNode){
      count1 = count1;
    } else if(n1 < currentNode && currentNode.left !== null){
      count1++
      dist1(currentNode.left);
    } else if(n1 > currentNode && currentNode.right !== null){
      count1++;
      dist1(currentNode.right);
    }
    console.log(count1);
    return count1;
  }
  let dist2 = currentNode => {
    if(n2 === currentNode){
      count2 = count2;
    } else if(n2 < currentNode && currentNode.left !== null){
      count2++
      dist2(currentNode.left);
    } else if(n2 > currentNode && currentNode.right !== null){
      count2++
      dist2(currentNode.right);
    }
    console.log(count2);
    return count2;
  }
  return dist1(currentNode) + dist2(currentNode);
};  