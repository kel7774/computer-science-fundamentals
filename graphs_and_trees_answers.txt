Exercises:

1. What is a binary tree and what makes it unique to other trees?

A binary tree is a data structure made up of nodes that contain pointers on the left and right that also contain a data element. A binary tree has a "root" pointer which is the topmost part of the tree. The left and right nodes point to smaller trees or "subtrees" making it unique from a linked list in that you can build more complex structures with left and right nodes.

2. What is a heuristic?

A heuristic is an algorithmic "best guess" at a complex problem that will take a reasonable amount of time to solve the problem, however, it may not be the most accurate or the best solution.

3. What is another problem besides the shortest-path problem that requires the use of heuristics?

One problem besides the shortest path is time accuracy. The company I work for provides our customers with an "estimated delivery time". This is for when a customer orders food from a restaurant, and the restaurant has a to select a prep time. Say the restaurant selects a 20 minute prep time to prepare the order. The customer will get a notification, but their notification will say, "Your food will be delivered in about 47 minutes." This is because the heuristic algorithm is taking into account how much time it will take a driver to A. Get to the restaurant, B. If the restaurant has a history of picking prep times that they exceed or are generally accurate, C. Google traffic updates at the current time of day, and many other factors. It's impossible to make an "exact" or accurate guess as to what time the customer will actually receive their food because of all of these factors that are not based on accuracy, but rather chance. A heuristic function typically suffices for such calculations.

4. What is the difference between a depth-first search and a breadth-first search?

Depth-First Search or DFS is a search that traverses the tree starting at the root and explores as far down each branch before having to backtrack.
Breadth-First Search or BDS is a search that traverses the tree starting at the root but explores the neighboring nodes (or rows) before moving to the next level of neighbors or nodes.

5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.

A graph that doesn't loop since it's a-cyclic, does not assign the cost of travel since it's unweighted and connection between two nodes is ambiguous because it neither starts nor ends at either node, just connects like a handshake since it's undirected.

6. What kind of graph is a binary search tree?

A binary search tree a undirected, a-cyclic, unweighted graph.


Programming Questions


1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.
2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.

class TreeNode {
  constructor(value){
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BST {
  constructor(){
    this.root = null;
  }
  insert(value){
    let newNode = new TreeNode(value);
    if(!this.root){
      this.root = newNode;
    } else {
      let currentNode = this.root;
      let hasNodeInserted = false;
      while(!hasNodeInserted){
        if(newNode.value < currentNode.value){
          if(!currentNode.left){
            currentNode.left = newNode;
            hasNodeInserted = true;
          } else {
            currentNode = currentNode.left;
          }
        } else {
          if(!currentNode.right){
            currentNode.right = newNode;
            hasNodeInserted = true;
          } else {
            currentNode = currentNode.right;
          }
        }
      }
    }
  }

  contains(value){
    let currentNode = this.root;
    while(currentNode){
      if(value === currentNode.value){
        return true;
      } else if(value < currentNode.value){
        currentNode = currentNode.left;
      } else {
        currentNode = currentNode.right;
      }
    }
    return false;
  }

  lca(n1, n2) {
    let currentNode = this.root;
    while(currentNode){
      if(n1 < currentNode.value && n2 < currentNode.value){
        currentNode = currentNode.left;
      } else if (n1 > currentNode.value && n2 > currentNode.value) {
        currentNode = currentNode.right;
      } else {
        return currentNode;
      }
    }
  }

  distance(n1, n2){
    let currentNode = this.lca(n1, n2);
    let counter1 = 0;
    let counter2 = 0;

    let distance1 = currentNode => {
      if(n1 < currentNode.value && currentNode.left !== null){
        counter1++;
        distance1(currentNode.left);
      } else if(n1 > currentNode.value && currentNode.right !== null){
        counter1++;
        distance1(currentNode.right);
      } else if(n1 === currentNode) {
        counter1 = counter1;
      }
      return counter1;
    }

    let distance2 = currentNode => {
      if(n1 < currentNode.value && currentNode.left !== null){
        counter2++;
        distance2(currentNode.left);
      } else if(n1 > currentNode.value && currentNode.right !== null){
        distance2(currentNode.right);
        counter2++;
      } else if(n2 === currentNode){
        counter2 = counter2;
      }
      return counter2;
    }
    return distance1(currentNode) + distance2(currentNode);
  }
}

let bst = new BST(50);

bst.insert(100);
bst.insert(200);
bst.insert(350);
bst.insert(17);
bst.insert(56);
bst.insert(95);

console.log(bst);
console.log(bst.contains(350));
console.log(bst.contains(222));
console.log(bst.distance(200, 17));