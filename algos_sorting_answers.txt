1. Write pseudocode for bubble sort.

FUNCTION bubbleSort(items)
    INIT startingValues equals items.slice();
    INIT length equals startingValues.length - 1
    DO
        INIT swapped equals false
        FOR i = 0; i < length; i++
            IF startingValues > startingValues[i + 1]
                INIT temp equals startingValues[i]
                startingValues[i] equals startingValues[i +1]
                startingValues[i + 1] equals temp;
                swapped equals true
            END IF
        END FOR
    WHILE swapped equals true
        DISPLAY startingValues
    END WHILE
END FUNCTION



2. Write pseudocode for quicksort.

FUNCTION quickSort(array)
    IF array.length < 2
        DISPLAY array
    END IF

    INIT pivotValue equalling array[0]
    INIT lessThanPivot
    INIT greaterThanPivot

    FOR i = 0; i < array.length; i++
        IF array[i] < pivotValue 
            APPEND array[i] TO lessThanPivot
        ELSE 
            APPEND array.[i] TO greaterThanPivot
        END IF
    END FOR
    
    DISPLAY quickSort OF lessThanPivot APPENDED TO pivotValue and quickSort of greatherThanPivot
END FUNCTION

3. We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. After looking at the pseudocode for the above sorting methods, identify why merge sort and quick sort are much more efficient than the others. Walking through each algorithm with a few sample collections may help.

4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is the ideal input for bucket sort?

Bucket sort is a distribution sort algorithm. It separates items in a collection into buckets that are then sorted individually using different sort methods. The ideal input for bucket sort would be something that can be easily distributed, and when memory space is not an issue.

