1. Write pseudocode for bubble sort.

FUNCTION bubbleSort(items)
    INIT startingValues equals items.slice();
    INIT length equals startingValues.length - 1
    DO
        INIT swapped equals false
        FOR i = 0; i < length; i++
            IF startingValues > startingValues[i + 1]
                INIT temp equals startingValues[i]
                startingValues[i] equals startingValues[i +1]
                startingValues[i + 1] equals temp;
                swapped equals true
            END IF
        END FOR
    WHILE swapped equals true
        DISPLAY startingValues
    END WHILE
END FUNCTION



2. Write pseudocode for quicksort.

FUNCTION quickSort(array)
    IF array.length < 2
        DISPLAY array
    END IF

    INIT pivotValue equalling array[0]
    INIT lessThanPivot
    INIT greaterThanPivot

    FOR i = 0; i < array.length; i++
        IF array[i] < pivotValue 
            APPEND array[i] TO lessThanPivot
        ELSE 
            APPEND array.[i] TO greaterThanPivot
        END IF
    END FOR
    
    DISPLAY quickSort OF lessThanPivot APPENDED TO pivotValue and quickSort of greatherThanPivot
END FUNCTION

3. We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. After looking at the pseudocode for the above sorting methods, identify why merge sort and quick sort are much more efficient than the others. Walking through each algorithm with a few sample collections may help.

Merge sort is more efficient than most of the algorithms since it only has two steps. It breaks the collection of items down into sub-collections, sorts those, then merges the sub-collections into one collection. Quicksort uses a divide and conquer method which is also faster than other algorithms. It uses three steps to accomplish sorting. It selects a pivot point, compares each item to the pivot point determining if the value goes to the left or right and repeats this with each unsorted sub-collection. It's 

Instead of scanning through all of the elements like most other algorithms, these two algorithms use a process of elimination or a divide and conquer type of strategy that is proven to be much faster when it comes to time complexity given the appropriate input.

4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is the ideal input for bucket sort?

Bucket sort is a distribution sort algorithm. It separates items in a collection into buckets that are then sorted individually using different sort methods. The ideal input for bucket sort would be something that can be easily distributed, and when memory space is not an issue.

